Adding type hints
=================

.. toctree::
   :maxdepth: 2

.. contents::
  :local:

Why use type hints?
-------------------

Python type hints are optional types that are declared for variables
in a Python program.

Python being a dynamic language, it is difficult to statically determine
the types of the variables defined in a Python source code.
To enjoy the benefits of static typing without losing
the flexibility of dynamic typing,
an optional static typing system, called **type hints** was proposed by the
`PEP 483 <https://www.python.org/dev/peps/pep-0483/>`_
and `PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_.

.. note:: All the examples shown here are only compatible with
  **Python version >= 3.6**.

A simple statements with type hints:

.. code-block:: python
  :linenos:

  # a variable with type hints
  pi: float = 3.1415

  # a method with type hints
  def to_hex(value: int) -> str:
      return hex(value)

Benefits of type hints
^^^^^^^^^^^^^^^^^^^^^^

The overall benefits of type hints are:

* Being able to run type checkers, and **statically validate Python code**.
* Write code that can be easily understood and **maintained**.
* Improve the **documentation** of the code.
  Also improves the "external" documentation generated by parsing the code.
* Use advanced IDEs tools that are based on type hints,
  ex: `PyCharm <https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html>`_

Type hints are by nature **optional**.
Adding or removing one or multiple type hints should not change the behavior
of a Python program.

How to use type hints?
----------------------

Before using type hints it is useful, *but not mandatory*,
to know the core ideas that shape this typing system.

The theory behind type hints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Gradual Typing
~~~~~~~~~~~~~~

Python type hints are based on
`gradual typing <https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/>`_.
Gradual typing is a typing system where some part of a source code
can be statistically typed when other parts dynamically typed.

Lets take this portion of code:

.. code-block:: python
  :linenos:

  x = 3       # dynamically typed as a "int"
  y: int = x  # statically typed as a "int"

While ``x`` type can be dynamically inferred (deduced) from its value,
``y`` type is statically written in the code.
For the programmers, the benefit is that they can gradually
define static types until they reach their goal.
Ex:

* Remove any type ambiguity in a program.
* Define types for all "public" application interfaces.
* Add types everywhere ?

Types V Classes
~~~~~~~~~~~~~~~

An other thing to know is that **types** used in type hints
are not always equivalent to **classes**.
In fact types are static representation of a variable while
classes are dynamic representation of the same variable.

You can see the difference in the following example:

.. code-block:: python
  :linenos:

  def even(value: int) -> Optional[str]:
      if value % 2 == 0:
          return "{} is even".format(value)
      # returns None if "value" is an odd number

Like the SchrÃ¶dinger's cat, the ``even`` function return type is
both ``str`` or ``NoneType``. This composed type is written ``Optional[str]``.

On the other hand, during the run-time the class of the returned variable
is not ``Optional[str]`` but either ``str`` or ``NoneType``.

Values types
^^^^^^^^^^^^

Classes as types
~~~~~~~~~~~~~~~~

All Python classes can be used as types for type hints:
``int``, ``float``, ``bool``, ``str``, ``bytes``, etc...

.. code-block:: python
  :linenos:

  x: int = 3
  y: float = 4

  x = y
  # ERROR: Incompatible types in assignment
  #   (expression has type "float", variable has type "int")
  #
  # -> should not set a "float" value in an "int" variable

Container types
~~~~~~~~~~~~~~~

However, some Python classes are not well suited for type hints.
Like container classes ``list``, ``dict``, ``set``, etc...

.. code-block:: python
  :linenos:

  x: list = [1, 2, 3]
  y: list = ['a', 'b', 'c']

  y[0] = x[0]
  # OK: both are lists of "something", but too permissive!

For better type checking, it is required to define the type of
the contained objects.
This is done using predefined types available in
`typing standard library <https://docs.python.org/3/library/typing.html>`_.

The previous code will then become:

.. code-block:: python
  :linenos:

  from typing import List


  x: List[int] = [1, 2, 3]
  y: List[str] = ['a', 'b', 'c']

  y[0] = x[0]
  # ERROR: No overload variant of "__setitem__" of "list"
  #   matches argument types "int", "int"
  #
  # -> the content types are not the same "int" != "str"

`Typing library <https://docs.python.org/3/library/typing.html>`_
defined types for a large range of containers including:
``List``, ``Set``, ``Dict`` and others.

It also gives access to abstract classes described in the
`collections.abc standard library <https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes>`_
like ``Iterator``, ``Iterable``, ``Mapping``, ``Coroutine``, etc...

Any type
~~~~~~~~

There is a special type name ``Any`` that can replace any type.
It can be used for variable types that are too complex,
or when we don't really care about the type of a given variable.

.. code-block:: python
  :linenos:

  from typing import Any


  x: Any = [1, 'two', [[[3]]]]
  y: Any = None
  z: int = 0

  y = x
  # OK: "Any" can be anything

  z = x
  # OK: "Any" can be anything

As shown in the last line ``z = x``, ``Any`` should be used with care
to avoid hiding mismatched types errors.

None type
~~~~~~~~~

An other special type is ``None``
that is used for variables that contains ``None`` value.
``None`` is used in type hints as a type instead of ``NoneType``
for simplicity I guess:

.. code-block:: python
  :linenos:

  def print_empty_div() -> None:
      print("<div></div>")
      # returns None

Aliases and new types
~~~~~~~~~~~~~~~~~~~~~

Programmers can create an **alias** for a type (put the type into a variables)
or even create new **new types**:

.. code-block:: python
  :linenos:

  from typing import NewType, List


  # Create a type alias
  Measures = List[int]

  a: Measures = [25, 38]
  b: Measures = [19, 19]

  # Create a new type
  Temperatures = NewType('Temperatures', List[int])
  x: Temperatures = Temperatures([15, 17])
  y: Temperatures = Temperatures([44, 36])

Instances of the new class must be created through the class constructor.

All of these types can be composed to produce types
that represent better the variable content.

Composed types
^^^^^^^^^^^^^^

There are multiple ways to compose types:

Union type
~~~~~~~~~~

``Union[TypeX, TypeY, TypeZ...]``:
represents a value that can have any of the types defined in the ``Union``.

.. code-block:: python
  :linenos:

  from typing import Union


  representation = input('choose "text" or "number" > ')
  output: Union[int, str] = 'twelve' if representation == 'text' else 12

  print(output)

Optional type
~~~~~~~~~~~~~

``Optional[TypeX]``: same as ``Union[TypeX, None]``
represents a value that can either be ``TypeX`` or ``None``.

.. code-block:: python
  :linenos:

  from typing import Optional


  a = {'top': 10}
  b: Optional[int] = a.get('bottom')

Tuple type
~~~~~~~~~~

``Tuple[TypeX, TypeY, TypeZ,...]``: represents a ``tuple``.
``TypeX``, ``TypeY``, etc... being the tuple item types.

.. code-block:: python
  :linenos:

  from typing import Tuple


  user: Tuple[str, int] = ("John", 36)

Callable type
~~~~~~~~~~~~~

``Callable[[TypaParam1, TypeParam2, ...], TypeReturn]``:
represents a ``callable``, method, ``class``, ``lambda``, metaclass etc...
``TypaParam1``, ``TypeParam2``, etc... are the parameters types
while ``TypeReturn`` is the callable return type.

.. code-block:: python
  :linenos:

  from typing import Callable


  def divide_by_two(value: int) -> float:
      return value / 2

  def run(method: Callable[[int], float], value: int) -> float:
      return method(value)

  result: float = run(divide_by_two, 3)

NoReturn type
~~~~~~~~~~~~~

``NoReturn``: an indication that a function will never return any value.

.. code-block:: python
  :linenos:

  from typing import NoReturn


  def fail(message: str) -> NoReturn:
      raise RuntimeError(message)

  x = fail("an error")
  # ERROR: Need type annotation for 'x'
  #
  # -> in fact, 'x' variable cannot receive a value from a function
  #   that returns nothing

Object oriented programming support
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Type hints support most of the modern object oriented programming features,
like:

ClassVar: class variable type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``ClassVar`` type is used to specify that a class attribute
is a class variable.
This attribute should not be used as an instance attribute.

.. code-block:: python
  :linenos:

  from typing import ClassVar


  class Robot:
      kill_switch: ClassVar[bool] = False


  bot = Robot()

  bot.kill_switch = True
  # ERROR: Cannot assign to class variable "kill_switch" via instance

TypeVar: type variables
~~~~~~~~~~~~~~~~~~~~~~~

Type variables are one of the base feature of abstract programming:
``TypeVarT = TypeVar('TypeVarT')``

Type variables are placeholders for actual types.

.. code-block:: python
  :linenos:

  from typing import TypeVar


  Item = TypeVar('ItemType')


  def middle(items: List[Item]) -> Item:
      pos = int(len(items) / 2)
      return items[pos]


  digit: int = middle([1, 2, 3])
  # OK: "Item" type variable is replaced by "int"

  letter: str = middle(['a', 'b', 'c'])
  # OK: "Item" type variable is replaced by "str"

Type variables can be restricted to certain types:
``TypeVarT = TypeVar('TypeVarT', TypeX, TypeY, ...)``

In this case only the listed types can replace the type variable.

.. code-block:: python
  :linenos:

  from typing import TypeVar


  Number = TypeVar('Number', int, float)


  def safe_div(dividend: Number, divisor: Number) -> float:
      return float('nan') if divisor == 0 else dividend / divisor


  x: float = safe_div(2, 3)
  # OK: "Number" type variable is replaced by "int"

  y: float = safe_div(9.1, 0.0)
  # OK: "Number" type variable is replaced by "float"

  z: float = safe_div('many', 'some')
  # ERROR: Value of type variable "Number" of "safe_div" cannot be "str"

Restricted type variables looks a lot like unions but with one catch.
The type variable is replaced by only one type,
when union can take any type:

.. code-block:: python
  :linenos:

  from typing import Union, TypeVar


  T = TypeVar('T', bytes, str)
  U = Union[bytes, str]


  # The function arguments "first" and "second" must have the same type
  def size_1(first: T, second: T) -> int:
      return len(first) + len(second)


  # The function arguments "first" and "second" can have different types
  def size_2(first: U, second: U) -> int:
      return len(first) + len(second)


  a: int = size_1('long', 'story')
  # OK: the function arguments have the same type "str"

  b: int = size_1('long', b'story')
  # ERROR: Value of type variable "T" of "size_1" cannot be "object"
  #
  # -> in fact the function arguments are "str" and "bytes" that have a common
  #   base class "object".
  #   But "object" is not a valid type for the type variable "T"

  c: int = size_2('long', b'story')
  # OK: unlike "size_1", here the function arguments can have different types
  #   "str" and "bytes". These types matches "Union[int, float, str]".

TypeVar: type bounds
~~~~~~~~~~~~~~~~~~~~

Type variables can be bound to a given type:
``TypeVarT = TypeVar('TypeVarT', bound=TypeX)``

Here the types that can replace the type variable ``TypeVarT``
are:
* The bound type ``TypeX``
* All ``TypeX`` derived classes (child-classes)

.. code-block:: python
  :linenos:

  from typing import TypeVar


  class SeriousError(Exception):
      def __init__(self, message: str) -> None:
          super().__init__('SERIOUS', message)


  # "T" can be "Exception" or any of its derived classes
  T = TypeVar('T', bound=Exception)


  def print_error(exception: T) -> None:
      text = ': '.join(exception.args)
      print(text)


  try:
      raise SeriousError("alert!")
  except SeriousError as error:
      print_error(error)  # prints Â«SERIOUS: alertÂ»
      # OK: "SeriousError" is a derived class of "Exception"

Type: add type hints to actual types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following type hints can be added to a variable definition
when it holds a class: ``Type[TypeX]``.

.. code-block:: python
  :linenos:

  from typing import Type


  boolean: Type[bool] = bool
  # OK: "bool" class has the type "Type(bool)"

This is pertucularly usefull when associated with type variables:

.. code-block:: python
  :linenos:

  from typing import TypeVar, Type


  T = TypeVar('T', bool, int)


  def empty(item_class: Type[T]) -> T:
      return item_class()


  boolean_false: bool = empty(bool)
  # OK: the function parameter type is "type(bool)" and it returns a "bool"

  number_zero: int = empty(int)
  # OK: the function parameter type is "type(int)" and it returns an "int"

  empty_string: str = empty(str)
  # ERROR: Value of type variable "T" of "empty" cannot be "str"
  #
  # -> Here, the only accepted types are "bool" and "int"

@overload: function overloading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A generic method can be defined using ``@overload`` decorator.
This decorator doesn't select which version of the function to call.
It actually defines the different type combinations
that are available for the function:

.. code-block:: python
  :linenos:

  from typing import overload


  @overload
  def dotted(*values: int) -> str:
    ...


  @overload
  def dotted(*values: str) -> str:
    ...


  # A "dotted" method without "@overload" must be defined
  def dotted(*values):
      text_values = [str(value) for value in values]
      return '.'.join(text_values)


  print(dotted(1, 234, 567))
  # OK: matches method variant "def dotted(*values: int) -> str"

  print(dotted('you', 'shall', 'not', 'pass'))
  # OK: matches method variant "def dotted(*values: str) -> str"

  print(dotted(b'hello'))
  # ERROR: No overload variant of "dotted" matches argument type "bytes"
  #   Possible overload variants:
  #      def dotted(*values: int) -> str
  #      def dotted(*values: str) -> str

Generic: generic types
~~~~~~~~~~~~~~~~~~~~~~

Generic types are types that uses type variables.
A variants of a generic class is defined by replacing the type variable
with an actual type.

For example:

* ``List[...]`` is a generic type
* ``List[int]`` is a variant of ``List[...]``
  where the type variable is replaced by ``int``
* ``List[str]`` is also a variant of ``List[...]``
  and here the type variable is replaced by ``str``

Generic types are defined using the type: ``Generic[TypeVarT, TypeVarU,...]``.

.. code-block:: python
  :linenos:

  import time
  from typing import Generic, TypeVar, List, NoReturn, Callable


  Param = TypeVar('Param')
  Result = TypeVar('Result')


  # A generic class that runs a task
  class Task(Generic[Param, Result]):
      def __init__(self, function: Callable[[Param], Result]) -> None:
          self.function = function

      def run(self, param: Param) -> Result:
          return self.function(param)


  def text_hash(text: str) -> int:
      return sum(ord(x) for x in text)


  def triple(items: List[int]) -> List[int]:
      return [item * 3 for item in items]


  def loop_forever() -> NoReturn:
      while True:
          time.sleep(1)


  hash_task: Task[str, int] = Task(text_hash)
  result: int = hash_task.run("gold diggers diggin' until they find oil")
  # OK: creates a variant of "Task" where
  #   - "Param" type variable is "str" and
  #   - "Result" type variable is "int"

  triple_task: Task[List[int], List[int]] = Task(triple)
  values: List[int] = triple_task.run([1, 2, 3])
  # OK: creates a variant of "Task" where
  #   - "Param" and "Result" type variables are both "List[int]"

  loop_task: Task[[], NoReturn] = Task(loop_forever)
  # ERROR: Argument 1 to "Task" has incompatible type Callable[[], NoReturn]";
  #   expected "Callable[[Any], Any]"
  #
  # -> There is no type that matches "Param" type variable

When there is an ambiguity about which types must replace the generic type
type variable, a variant of the generic type can be explicitly instantiated:

.. code-block:: python
  :linenos:

  from typing import Generic, TypeVar, Optional


  Item = TypeVar('Item')


  # A generic class that runs a task
  class Store(Generic[Item]):
      def __init__(self) -> None:
          self.item: Optional[Item] = None

      def set(self, item: Item) -> None:
          self.item = item

      def get(self) -> Optional[Item]:
          return self.item


  store_x = Store[str]()
  # OK: the variant of "Store[...]" where "Item" is replaced by "str" type
  #   is explicitly used

  store_x.set('javascript')
  x: Optional[str] = store_x.get()

  store_y: Store[int] = Store()
  # OK: from the variable type "Store[int]", the type checker guesses that
  #   the variant "Store[int]" of "Store[...]" generic type is used here

  store_y.set(3)
  y: Optional[int] = store_y.get()

  store_z = Store()
  # ERROR: Need type annotation for "store_z"
  #
  # ->there is no type information that the type checker can use to determine
  #   which type replaces the type variable "Item"


Generic types can be partially defined using type aliases:

.. code-block:: python
  :linenos:

  from typing import Dict, TypeVar


  T = TypeVar('T')
  StrDict = Dict[str, T]
  # The generic type "Dict[Key, Value]" is partially defined:
  #   the type variable "Key" is replaced by the type "str"
  #   while "Value" remains a type variable (renamed "T")

  a: StrDict[int] = {'a': 1}
  # OK: "StrDict[int]" is in fact "Dict[str, int]".
  #   And "Dict[str, int]" matches the value type

  b: StrDict[bool] = {'b': 1.2}
  # ERROR: Dict entry 0 has incompatible type "str": "int";
  #   expected "str": "bool"
  #
  # -> the defined type "StrDict[bool]" is in fact "Dict[str, bool]"
  #   but "Dict[str, bool]" doesn't match the value type "Dict[str, float]"

More advanced usages of generic types are described in
`typing module documentation <https://docs.python.org/3/library/typing.html#user-defined-generic-types>`_.

Variance: invariant, covariant and contravariant
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's consider two types ``Parent`` and ``Child``
that have a sub-typing relation, and a composed type ``Container[T]``.

The variance refers to the kind of sub-typing relation
that ``Container[Parent]`` and ``Container[Child]`` have:

.. code-block:: python
  :linenos:

  from typing import Generic, TypeVar


  class Parent: pass
  class Child(Parent): pass

  T = TypeVar('T')
  class Container(Generic[T]): pass


  x: Container[Parent] = Container[Child]()
  # ERROR: Incompatible types in assignment (
  #   expression has type "Container[Child]",
  #   variable has type "Container[Parent]")
  #
  # -> "T" is invariant:
  #   no special relation between "Container[Parent]" and "Container[Child]"

In the example above ``Container[Parent]`` and ``Container[Child]``
have no special relation, because the type variable ``T`` is **invariant**
by default.

To replicate the sub-typing relation,
make ``Container[Parent]`` the base class of ``Container[Child]``,
the type variable ``T`` must be **covariant**:

.. code-block:: python
  :linenos:

  from typing import Generic, TypeVar


  class Parent: pass
  class Child(Parent): pass

  T = TypeVar('T', covariant=True)
  class Container(Generic[T]): pass


  x: Container[Parent] = Container[Child]()
  # OK: "T" is covariant:
  #   "Container[Parent]" is then a base class of "Container[Child]"

To reverse the sub-typing relation,
make ``Container[Child]`` the base class of ``Container[Parent]``,
the type variable ``T`` must be **contravariant**:

.. code-block:: python
  :linenos:

  from typing import Generic, TypeVar


  class Parent: pass
  class Child(Parent): pass

  T = TypeVar('T', contravariant=True)
  class Container(Generic[T]): pass


  x: Container[Child] = Container[Parent]()
  # OK: "T" is contravariant:
  #   "Container[Child]" is then a base class of "Container[Parent]"

Here is a full fledged example that demonstrate the variance of type variables.
In this example a plug-in system is defined:

* all plug-ins share the same base type ``BasePlugIn``
* a child type ``SecurePlugIn``
  inherit from few "secure" plug-ins types. that have been manually selected
* a ``PlugInSandbox[T]`` runs a plug-in in a sandbox,
  with no special subtyping relation. Therefore ``T`` is **invariant**.
* ``PlugInInfo[U]`` retrieves the plug-in name,
  ``PlugInInfo[BasePlugIn]`` is the base type of all plug-in name reader
  (``PlugInInfo[U]`` where ``U`` is a plug-in type).
  In consequence, ``U`` is **covariant**.
* ``PlugInManager[V]`` checks if a plug-in is available.
  ``PlugInManager[SecurePlugIn]`` is the base type of all managed
  secure plug-ins (``PlugInManager[V]`` where ``V`` is a secure plug-in).
  In other words ``V`` is **contravariant**.

.. code-block:: python
  :linenos:

  from ast import literal_eval
  from contextlib import contextmanager
  import time
  from typing import Generic, TypeVar, Optional, Generator


  """
  PlugIn classes hierarchy:

  BasePlugIn âââ¬ââ> LowerPlugIn âââ¬ââ> SecurePlugIn
               âââ> TitlePlugIn âââ
               â
               âââ> EvalPlugIn (not secure)
  """


  class BasePlugIn:
      def execute(self, data: str) -> str:
          raise NotImplementedError()


  class LowerPlugIn(BasePlugIn):
      def execute(self, data: str) -> str:
          return data.lower()


  class TitlePlugIn(BasePlugIn):
      def execute(self, data: str) -> str:
          return data.title()


  class EvalPlugIn(BasePlugIn):
      def execute(self, data: str) -> str:
          # evaluation of data provided by the user
          # without error handling: NOT SAFE
          return str(literal_eval(data))


  class SecurePlugIn(LowerPlugIn, TitlePlugIn):
      pass


  # Create the plugin that will be used in all examples above
  title_plugin = TitlePlugIn()


  #------------------------------------------------------------------------------
  # Invariant type variables
  #------------------------------------------------------------------------------


  T = TypeVar('T')


  class PlugInSandbox(Generic[T]):
      def __init__(self, plugin: T) -> None:
          self.plugin: T = plugin

      # A context manager that mimic a sandbox
      # this code is not relevant to understand the types relations
      @contextmanager
      def sandboxed(self) -> Generator[T, None, None]:
          print("[Sandbox ON]")
          yield self.plugin
          print("[Sandbox OFF]")


  sandbox: PlugInSandbox[TitlePlugIn] = PlugInSandbox[TitlePlugIn](title_plugin)
  # OK: value and variable have the same type: "PlugInSandbox[TitlePlugIn]"

  with sandbox.sandboxed() as safe_plugin:
      sandboxed_execution_result = safe_plugin.execute('here we go')
      print(sandboxed_execution_result)
      # prints:
      #   [Sandbox ON]
      #   Here We Go
      #   [Sandbox OFF]

  base_sandbox: PlugInSandbox[BasePlugIn] = PlugInSandbox[TitlePlugIn](
      title_plugin)
  # ERROR: Incompatible types in assignment (
  #   expression has type "PlugInSandbox[TitlePlugIn]",
  #   variable has type "PlugInSandbox[BasePlugIn]")
  #
  # -> "Container[Parent]" to "Container[Child]" type conversions are only valid
  #   for *contravariant* type variables. But here "T" type variable is invariant

  secure_sandbox: PlugInSandbox[SecurePlugIn] = PlugInSandbox[TitlePlugIn](
      title_plugin)
  # ERROR: Incompatible types in assignment (
  #   expression has type "PlugInSandbox[TitlePlugIn]",
  #   variable has type "PlugInSandbox[SecurePlugIn]")
  #
  # -> "Container[Child]" to "Container[Parent]" type conversions are only valid
  #   for *covariant* type variables. But here "T" type variable is invariant


  #------------------------------------------------------------------------------
  # Covariant type variables
  #------------------------------------------------------------------------------


  U = TypeVar('U', covariant=True)


  class PlugInInfo(Generic[U]):
      def __init__(self, plugin: U) -> None:
          self.plugin: U = plugin

      def name(self) -> str:
          return self.plugin.__class__.__name__


  info: PlugInInfo[TitlePlugIn] = PlugInInfo[TitlePlugIn](title_plugin)
  # OK: value and variable have the same type: "PlugInInfo[TitlePlugIn]"

  plugin_name = info.name()
  print(plugin_name)  # prints Â«TitlePlugInÂ»

  base_info: PlugInInfo[BasePlugIn] = PlugInInfo[TitlePlugIn](title_plugin)
  # OK: "U" is covariant, therefore:
  #   "Container[Child]" to "Container[Parent]" type conversions are valid

  base_plugin_name = base_info.name()
  print(base_plugin_name)  # Â«TitlePlugInÂ»
  # Note that the type conversion doesn't affect the plug-in runtime class
  #   that remains "TitlePlugIn"

  secure_info: PlugInInfo[SecurePlugIn] = PlugInInfo[TitlePlugIn](title_plugin)
  # ERROR: Incompatible types in assignment (
  #   expression has type "PlugInInfo[TitlePlugIn]",
  #   variable has type "PlugInInfo[SecurePlugIn]")
  #
  # -> "Container[Parent]" to "Container[Child]" type conversions are only valid
  #   for *contravariant* type variables. But here "U" type variable is covariant


  #------------------------------------------------------------------------------
  # Contrariant type variables
  #------------------------------------------------------------------------------


  V = TypeVar('V', contravariant=True)


  class PlugInManager(Generic[V]):
      def __init__(self, plugin: Optional[V] = None) -> None:
          self.plugin: Optional[V] = plugin

      def is_available(self) -> bool:
          return self.plugin is not None


  manager: PlugInManager[TitlePlugIn] = PlugInManager[TitlePlugIn](title_plugin)
  # OK: value and variable have the same type: "PlugInManager[TitlePlugIn]"

  if manager.is_available():
      message = manager.plugin.execute("hip hip hooray")
      print(message)  # prints Â«Hip Hip HoorayÂ»

  base_manager: PlugInManager[BasePlugIn] = PlugInManager[TitlePlugIn]()
  # ERROR: Incompatible types in assignment (
  #   expression has type "PlugInManager[TitlePlugIn]",
  #   variable has type "PlugInManager[BasePlugIn]")
  #
  # -> "Container[Child]" to "Container[Parent]" type conversions are only valid
  #   for *covariant* type variables. But here "V" type variable is contravariant

  secure_manager: PlugInManager[SecurePlugIn] = PlugInManager[TitlePlugIn]()
  # OK: "V" is contravariant, therefore:
  #   "Container[Parent]" to "Container[Child]" type conversions are valid

  if not secure_manager.is_available():
      print("exiting...")  # prints Â«exiting...Â»

Other features
^^^^^^^^^^^^^^

There are practical features that can help programmers write type hints
with more ease.

cast: explicit type casting
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes the variables content type doesn't exactly match the expected type.
If this mismatch doesn't harm the program, it is possible to explicitly
change the type of the variable using ``cast(TypeX, variable)`` method.

.. code-block:: python
  :linenos:

  from typing import cast, List


  x: List[int] = [0, 1]

  y: List[float] = x
  # ERROR: Incompatible types in assignment (
  #   expression has type "List[int]",
  #   variable has type "List[float]")
  #
  # -> the conversion from "List[float]" to "List[int]" is not implicit
  #   even if "int" can be implicitly converted to "float"

  z: List[float] = cast(List[float], x)
  # OK: we explicitly convert "List[int]" into "List[float]"

If the goal is to convert a value (change the run-time class of value),
you should convert the variable instead of casting its static type.
In fact the static type casting doesn't actually change the variable class:

.. code-block:: python
  :linenos:

  from typing import cast, List


  message: str = "SUCCESS"
  status_code: int = cast(int, message)
  # OK: "status_code" static type have been converted from "str" to "int"
  #   BUT "status_code" class is "str", like "message".
  #   Python objects run-time classes are not affected by static type casting.

  print(status_code)  # prints Â«SUCCESSÂ»

Classes to hold data: NamedTuple, @dataclass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are at least twoo ways to create data holder classes that takes advantage
of type hints:

* ``NamedTuple``
  base class defined in
  `typing standard module <https://docs.python.org/3/library/typing.html#typing.NamedTuple>`_
  and compatible with **Python >= 3.6**
* ``@dataclass`` decorator defined in
  `dataclasses standard module <https://docs.python.org/3/library/dataclasses.html#module-level-decorators-classes-and-functions>`_
  and compatible with **Python >= 3.7**

They are replacements and/or complements to ``collections.namedtuple``.
Here is an example using ``@dataclass``:

.. code-block:: python
  :linenos:

  from dataclasses import dataclass


  @dataclass
  class Voxel:
      x: int
      y: int
      z: int
      color: str = 'blue'

  broken_voxel: Voxel = Voxel(1.0, -2, 3)
  # ERROR: Argument 1 to "Voxel" has incompatible type "float"; expected "int"
  #
  # -> the first argument "x" has the wrong type: "float" instead of "int"

  voxel: Voxel = Voxel(1, -2, 3)
  # OK: all the arguments have the right type

  print(voxel)  # prints Â«Voxel(x=1, y=-2, z=3, color='blue')Â»

Type definition with forward references
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When a type hint contain a reference to a type that have not been defined yet,
this type name must be written as a string:

.. code-block:: python
  :linenos:

  from typing import Optional


  class Chain:
      # the type "Chain" is not fully defined here, all the references to
      # "Chain" type should be written as a string "'Chain'"

      def __init__(self, value: int, next: Optional['Chain'] = None) -> None:
          self.value = value
          self._next = next

      @property
      def next(self) -> 'Chain':
          if self._next is None:
              raise ValueError("Last item: there is are next items")
          return self._next


  head: Chain = Chain(1, Chain(2, Chain(3)))
  last_value: int = head.next.next.value
  print(last_value)  # prints: 3

In Python 4, forward references will be supported by default
thanks to the Â«Postponed Evaluation of AnnotationsÂ» feature introduced by the
`PEP 563 <https://www.python.org/dev/peps/pep-0563/#enabling-the-future-behavior-in-python-3-7>`_.
It will no longer be required to write type names as strings.

This feature can be used today on Python 3.7 with the following import:
``from __future__ import annotations``

.. code-block:: python
  :linenos:

  from __future__ import annotations

  from typing import Optional


  class Chain:
      # "Chain" type can now be used in type annotations

      def __init__(self, value: int, next: Optional[Chain] = None) -> None:
          pass

How to add static types to Guesslang source code?
-------------------------------------------------

Now let's put all that into practice by adding type hints to Guesslang package.

Current status
^^^^^^^^^^^^^^

Guesslang core package has more than 700 lines of codes, with 29 functions.
Not counting the tools, tests and side packages.

Today 70% of Guesslang source code is covered by unit tests.

.. code-block:: text

  Name                     Stmts   Miss  Cover   Missing
  ------------------------------------------------------
  guesslang/__init__.py        4      0   100%
  guesslang/__main__.py       70     70     0%   3-112
  guesslang/config.py         50     21    58%   38-45, 53-65, 77-79, 95-97
  guesslang/extractor.py      47      2    96%   51, 78
  guesslang/guesser.py       124      3    98%   196, 254, 256
  guesslang/utils.py          55      9    84%   77, 82-89, 121
  ------------------------------------------------------
  TOTAL                      350    105    70%

The goal
^^^^^^^^

The main goal here is to improve the readability of the code,
precisely the parts of the code that interacts with ``tensorflow``.

Hopefully type hints will also reveal any hidden typing bug that
unit tests didn't detect.

On the other hand it would be good to avoid spending too much time
adding type hints to portions of code where type hints are not required.

Definitions with type hint
~~~~~~~~~~~~~~~~~~~~~~~~~~

To reach the goals defined above, type hints will be added
to the following kind of definitions:
* Method definition
* Class definition
* Class public attributes definitions
* Ambiguous variable definition

In addition to that, the added type hints should be readable and concise...
because *this is not C++* ð

.. code-block:: c++
  :linenos:

  // The kind of long C++ function types
  //  that I would like to avoid in my Python function definitions
  //  (but I still love C++)
  static inline std::map<std::string, int> zip_and_map(
      std::list<std::string> keys,
      std::list<int> values) {
    ...
  }

Setting up the static checker
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Mypy & Typeshed tools
~~~~~~~~~~~~~~~~~~~~~

The checker I used is the de facto standard Python static type checker
`Mypy <http://mypy.readthedocs.io/>`_.
Mypy is maintained by Python core developers including
`Guido van Rossum <https://en.wikipedia.org/wiki/Guido_van_Rossum>`_,
the Python language creator.
Mypy provide quite detailled error message
that helps quickly fix the typing issues.

To overcome the lack of type annotations in Python standard library
as well as third party packages, Mypy uses
`Typeshed package <https://github.com/python/typeshed/>`_.

Typeshed is a collection of type annotations for Python standard library,
``builtins`` and some third party packages.

You can install Mypy with the following command:

.. code-block:: shell
  :linenos:

  pip install mypy

Running the checker
^^^^^^^^^^^^^^^^^^^

Run static type checking
~~~~~~~~~~~~~~~~~~~~~~~~

The type checker is executed with the command line bellow:

.. code-block:: shell
  :linenos:

  mypy --strict --ignore-missing-imports guesslang/

Explanation:

* ``mypy``: the static type checker command line tool

* ``--strict``: option to check everything,
  will print an **error** or a **warning** if any type issue is found.

* ``--ignore-missing-imports``:
  ignore third party dependencies that lacks type hints.
  Guesslang is based on ``numpy`` and ``tensorflow`` that doesn't
  provide type hints information.
  In addition to that, no type hints is defined for these third party packages
  in `typeshed <https://github.com/python/typeshed>`_.
  Without this option the following error would be generated:

  .. code-block:: text
    :linenos:

    guesslang/config.py:12: error: Cannot find module named 'tensorflow'
    guesslang/config.py:12: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
    guesslang/utils.py:10: error: No library stub file for module 'numpy'
    guesslang/utils.py:10: note: (Stub files are from https://github.com/python/typeshed)
    guesslang/guesser.py:10: error: Cannot find module named 'tensorflow'

Running Mypy will list all the typing issues found by the checker.
If there is no typing issue Mypy won't print anything.

Fixing static typing issues in Guesslang project
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Guess methods types from Mypy error messages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first and most obvious way to fix static typing issues highlighted by Mypy
is to read Mypy error message and warning and apply the proposed fixes.

For example the error bellow is fixed by changing the argument type
from ``str`` to ``int``:

.. code-block:: text
  :linenos:

  error: Argument 2 to "_pop_many" has incompatible type "int"; expected "str"

In addition to that, there are several ways to get information about the types.

Guess methods types from Guesslang documentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In fact most of Guesslang methods are documented.
The arguments and return types are detailed in the documentation.
We just have to reuse them as type hints.

For example:

.. code-block:: python
  :linenos:

  def learn(self, input_dir):
      """Learn languages features from source files.

      :raise GuesslangError: when the default model is used for learning
      :param str input_dir: source code files directory.
      :return: learning accuracy
      :rtype: float
      """
      ...
      return accuracy

The method argument type is given in ``:param str input_dir:``
and the return type in ``:rtype: float``.
The type hints for this method are then:

.. code-block:: python
  :linenos:

  def learn(self, input_dir: str) -> float:
      """Learn languages features from source files.

      :raise GuesslangError: when the default model is used for learning
      :param input_dir: source code files directory.
      :return: learning accuracy
      """
      ...
      return accuracy

Guess methods types from the unit tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All Guesslang "public" methods are tested by unit tested.
Literal values (with an obvious type) are sent to these methods.
These types can be used to write the methods type hints.

Example:

.. code-block:: python
  :linenos:

  def test_split():
      text = """
          int * last(int *tab, int size)
          {
          \treturn tab + (size - 1);
          }
      """
      tokens = [
          '\n', 'int', '*', 'last', '(', 'int', '*', 'tab', ',', 'int', 'size',
          ')', '\n', '{', '\n', 'return', 'tab', '+', '(', 'size', '-', '1', ')',
          ';', '\n', '}', '\n'
      ]

      assert extractor.split(text) == tokens

From this test we can easily deduce that ``split(...)`` methods
takes a string ``str`` as argument and returns a list of strings ``List[str]``:

.. code-block:: python
  :linenos:

  def split(text: str) -> List[str]:
      ...

Special types
~~~~~~~~~~~~~

Some type hints where less usual that the other ones.
Like:
* A method that returns a tuple that contains

.. code-block:: python
  :linenos:

  def probable_languages(
          self,
          text: str,
          max_languages: int = 3) -> Tuple[str, ...]:
      ...

* A method that takes a file object or STD-IN as argument: ``typing.TextIO``

.. code-block:: python
  :linenos:

  def _read_file(input_file: TextIO) -> str:
      ...

* A really long type that have been replaced by an alias
  to avoid over-complicated type hints:

.. code-block:: python
  :linenos:

  DataSet = Tuple[Sequence[Sequence[float]], Sequence[int]]

* A method that produces a callable object.
  The callable returns tuple of ``Any`` instead of an identifiable type
  because the tuple will only be used in a code that
  will not be checked by the static type checker
  (Tensorflow third party package).

.. code-block:: python
  :linenos:

  def _to_func(vector: DataSet) -> Callable[[], Tuple[Any, Any]]:
      return lambda: (
          tf.constant(vector[0], name='const_features'),
          tf.constant(vector[1], name='const_labels'))

When guessing types is not enough
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A little Quiz: There is a Guesslang method that loads a JSON string,
what should be its return type?

.. code-block:: python
  :linenos:

  def config_dict(name):
      """Load a JSON configuration dict from Guesslang config directory.

      :param str name: the JSON file name.
      :return: configuration
      :rtype: dict
      """
      content = ...  # read file content
      return json.loads(content)

The answer: Â«We can't define JsonObject in a very tight way ââ
`by Guido van Rossum <https://github.com/python/typing/issues/182#issuecomment-199872724>`_Â»

The closest definition of ``JsonObject`` would be:

.. code-block:: python
  :linenos:

  import json
  from typing import Dict, List, Union


  JsonObject = Union[
      None,
      int,
      bool,
      str,
      List['JsonObject'],
      Dict[str, 'JsonObject']
  ]
  # ERROR: Recursive types not fully supported yet,
  #   nested types replaced with "Any"
  #
  # "JsonValue" type alias cannot have a reference to itself


  value: JsonValue = json.loads('{"a": null}')

Unfortunately it is not yet possible to define recursive type aliases.
As a workaround, the ``JsonObject`` is defined
by ``Dict[str, Any]`` in Guesslang:

.. code-block:: python
  :linenos:

  def config_dict(name: str) -> Dict[str, Any]:
      """Load a JSON configuration dict from Guesslang config directory.

      :param str name: the JSON file name.
      :return: configuration
      :rtype: dict
      """
      content = ...  # read file content
      return json.loads(content)

Updating Guesslang documentation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To document the process of adding static types to Guesslang this documentation
page was written. This page is also a tour of Python static typing feature,
a feature that might be pillar of the next exciting Python features.

The documentation generated from the source code have been improved using
the package:
`sphinx-autodoc-typehints <https://github.com/agronholm/sphinx-autodoc-typehints>`_

With this package, the type annotations are automatically added to the methods
definitions.

Any actual benefits?
--------------------

As expected, adding type information to Guesslang has a positive impact
on the project:

* The source code is easier to read and understand.
* The project is statically type checked now.
  The type checking is now part of the continuous integration.
* The code is more consistent now. It is easier to see where an argument
  with a wrong type is sent to a function:
  there where a mix-up between ``list`` and ``type`` that have been fixed
  thanks to the type checking.
* The documentation is easier to write, no need to add type information in
  the doc-string.
* The generated documentation is more detailed.

On the over hand:

* The new type checking didn't uncover new bugs (just little improvements).
  It only shows that tests are more suitable than type checking to find bugs.
* Few tweaks where required to fix all the type checking issues.
  In most cases setting the variable type, casting (``cast``) and
  using the ``Any`` type where enough to solve the most complex issues.

Finally
^^^^^^^

I would say that type hints are a big step forward for Python language,
it builds a solid bridge between the statically typed languages world and
the dynamically typed languages one.
Of course the bigger and more complex the project is
the bigger the type hints benefits will be.

Currently I'm quite happy with them and I will use them in more projects.
