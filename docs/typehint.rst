Adding type hints
=================

.. toctree::
   :maxdepth: 2

Why use type hints?
-------------------

Python type hints are optional types that are declared for variables
in a Python program.

Python being a dynamic language, it is difficult to statically determine
the types of the variables defined in a Python source code.
To enjoy the benefits of static typing without losing
the flexibility of dynamic typing,
an optional static typing system, called **type hints** was proposed by the
`PEP 483 <https://www.python.org/dev/peps/pep-0483/>`_
and `PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_.

.. note:: All the examples shown here are only compatible with
  **Python version >= 3.6**.

A simple statements with type hints:

.. code-block:: python
  :linenos:

  # a variable with type hints
  pi: float = 3.1415

  # a method with type hints
  def to_hex(value: int) -> str:
      return hex(value)

Benefits of type hints
^^^^^^^^^^^^^^^^^^^^^^

The cummulated benefits of type hints are:

* Being able to run type checkers, and **statically validate Python code**.
* Write code that can be easily understood and **maintained**.
* Improve the **documentation** of the code.
  Also improves the "external" documentation generated by parsing the code.
* Use advanced IDEs tools that are based on type hints,
  ex: `PyCharm <https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html>`_

Type hints are by nature **optional**.
Adding or removing one or multiple type hints should not change the behaviour
of a Python program.

How to use type hints?
----------------------

Before using type hints it is useful, *but not mandatory*,
to know the core ideas that shape this typing system.

The theory behind type hints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Gradual Typing
~~~~~~~~~~~~~~

Python type hints are based on
`gradual typing <https://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/>`_.
Gradual typing is a typing system where some part of a source code
can be statistically typed when other parts dynamically typed.

Lets take this portion of code:

.. code-block:: python
  :linenos:

  x = 3       # dynamically typed as a "int"
  y: int = x  # statically typed as a "int"

While ``x`` type can be dynamically inferred (deduced) from its value,
``y`` type is statically written in the code.
For the programmers, the benefit is that they can gradually
define static types until they reach their goal.
Ex:

* Remove any type ambiguity in a program.
* Define types for all "public" application interfaces.
* Add types everywhere ?

Types V Classes
~~~~~~~~~~~~~~~

An other thing to know is that **types** used in type hints
are not always equivalent to **classes**.
In fact types are static representation of a variable while
classes are dynamic representation of the same variable.

You can see the difference in the following example:

.. code-block:: python
  :linenos:

  def even(value: int) -> Optional[str]:
      if value % 2 == 0:
          return "{} is even".format(value)
      # returns None if "value" is an odd number

Like the Schr√∂dinger's cat, the ``even`` function return type is
both ``str`` or ``NoneType``. This composed type is written ``Optional[str]``.

On the other hand, during the runtime the class of the returned variable
is not ``Optional[str]`` but either ``str`` or ``NoneType``.

Values types
^^^^^^^^^^^^

Classes as types
~~~~~~~~~~~~~~~~

All Python classes can be used as types for type hints:
``int``, ``float``, ``bool``, ``str``, ``bytes``, etc...

.. code-block:: python
  :linenos:

  x: int = 3
  y: float = 4
  x = y  # Not valid: should not set a "float" value in an "int" variable

Container types
~~~~~~~~~~~~~~~

However, some Python classes are not well suited for type hints.
Like container classes ``list``, ``dict``, ``set``, etc...

.. code-block:: python
  :linenos:

  x: list = [1, 2, 3]
  y: list = ['a', 'b', 'c']
  y[0] = x[0]  # Valid: both are lists of "something", but too permissive

For better type checking, it is required to define the type of
the contained objects.
This is done using predefined types availaple in
`typing standard library <https://docs.python.org/3/library/typing.html>`_.

The previous code will then become:

.. code-block:: python
  :linenos:

  from typing import List


  x: List[int] = [1, 2, 3]
  y: List[str] = ['a', 'b', 'c']
  y[0] = x[0]  # Not valid: the content types are not the same "int" != "str"

`Typing library <https://docs.python.org/3/library/typing.html>`_
defined types for a large range of containers including:
``List``, ``Set``, ``Dict`` and others.

It also gives access to abstract classes described in the
`collections.abc standard library <https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes>`_ like ``Iterator``, ``Iterable``, ``Mapping``, ``Coroutine``, etc...

Any type
~~~~~~~~

There is a special type name ``Any`` that can replace any type.
It can be used for variable types that are too complex,
or when we don't really care about the type of a given variable.

.. code-block:: python
  :linenos:

  from typing import Any


  x: Any = [1, 'two', [[[3]]]]
  y: Any = None
  z: int = 0

  y = x  # Valid: "Any" can be anything
  z = x  # Valid: "Any" can be anything

As shown in the last line ``z = x``, ``Any`` should be used with care
to avoid hiding mismatched types errors.

None type
~~~~~~~~~

An other special type is ``None``
that is used for variables that contains ``None`` value.
``None`` is used in type hints as a type instead of ``NoneType``
for simplicity I guess:

.. code-block:: python
  :linenos:

  def print_empty_div() -> None:
      print("<div></div>")
      # returns None

Aliases and new types
~~~~~~~~~~~~~~~~~~~~~

Programmers can create an **alias** for a type (put the type into a variables)
or even create new **new types**:

.. code-block:: python
  :linenos:

  from typing import NewType, List


  # Create a type alias
  Measures = List[int]

  a: Measures = [25, 38]
  b: Measures = [19, 19]

  # Create a new type
  Temperatures = NewType('Temperatures', List[int])
  x: Temperatures = Temperatures([15, 17])
  y: Temperatures = Temperatures([44, 36])

Instances of the new class must be created through the class constructor.

All of these types can be composed to produce types
that represent better the variable content.

Composed types
^^^^^^^^^^^^^^

There are multiple ways to compose types:

Union type
~~~~~~~~~~

``Union[TypeX, TypeY, TypeZ...]``:
represents a value that can have any of the types defined in the ``Union``.

.. code-block:: python
  :linenos:

  from typing import Union


  representation = input('choose "text" or "number" > ')
  output: Union[int, str] = 'twelve' if representation == 'text' else 12

  print(output)

Optional type
~~~~~~~~~~~~~

``Optional[TypeX]``: same as ``Union[TypeX, None]``
represents a value that can either be ``TypeX`` or ``None``.

.. code-block:: python
  :linenos:

  from typing import Optional


  a = {'top': 10}
  b: Optional[int] = a.get('bottom')

Tuple type
~~~~~~~~~~

``Tuple[TypeX, TypeY, TypeZ,...]``: represents a ``tuple``.
``TypeX``, ``TypeY``, etc... being the tuple item types.

.. code-block:: python
  :linenos:

  from typing import Tuple


  user: Tuple[str, int] = ("John", 36)

Callable type
~~~~~~~~~~~~~

``Callable[[TypaParam1, TypeParam2, ...], TypeReturn]``:
represents a ``callable``, method, ``class``, ``lambda``, metaclass etc...
``TypaParam1``, ``TypeParam2``, etc... are the parameters types
while ``TypeReturn`` is the callable return type.

.. code-block:: python
  :linenos:

  from typing import Callable


  def divide_by_two(value: int) -> float:
      return value / 2

  def run(method: Callable[[int], float], value: int) -> float:
      return method(value)

  result: float = run(divide_by_two, 3)

NoReturn type
~~~~~~~~~~~~~

``NoReturn``: an indication that a function will never return any value.

.. code-block:: python
  :linenos:

  from typing import NoReturn


  def fail(message: str) -> NoReturn:
      raise RuntimeError(message)

Object oriented programming support
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Type hints support most of the modern object oriented programming features,
like:

* Class variable restriction
* Type variables.
* Generic classes (known as templates in some languages).
* Method overloading.
* Covariance and contravariance.

.. code-block:: python
  :linenos:

  from typing import Generic, TypeVar


  T = TypeVar('T')
  R = TypeVar('R')


  class Delayed(Generic[T, R]):
      def __init__(self, param: T) -> None:
          ...

      def __call__(self) -> R:
          ...


  class TextHash(Delayed):
      def __init__(self, text: str) -> None:
          self.text = text

      def __call__(self) -> int:
          return sum(ord(x) for x in self.text)


  compute_hash: Delayed = TextHash("gold diggers diggin' until they find oil")

  lyrics_hash: int = compute_hash()
  print(lyrics_hash)
  # prints: 3759

This section will be expanded later...

Other features
^^^^^^^^^^^^^^

* Explicit casting.
* Dataclasses.
* Variable annotation restrictions.

This section will be expanded later...

Now let's put all that into pratice.

How to "type hint" Guesslang?
-----------------------------

Current status
^^^^^^^^^^^^^^

Guesslang core package has more than 700 lines of codes, with 29 functions.
Not counting the tools, tests and side packages.

Today 70% of Guesslang source code is covered by unit tests.

.. code-block:: text

  Name                     Stmts   Miss  Cover   Missing
  ------------------------------------------------------
  guesslang/__init__.py        4      0   100%
  guesslang/__main__.py       70     70     0%   3-112
  guesslang/config.py         50     21    58%   38-45, 53-65, 77-79, 95-97
  guesslang/extractor.py      47      2    96%   51, 78
  guesslang/guesser.py       124      3    98%   196, 254, 256
  guesslang/utils.py          55      9    84%   77, 82-89, 121
  ------------------------------------------------------
  TOTAL                      350    105    70%

The goal
^^^^^^^^

The main goal here is to improve the readability of the code,
precisely the parts of the code that interacts with ``tensorflow``.

Hopefully type hints will also reveal any hidden typing bug that
unit tests didn't detect.

Spending time adding hints only for the sake of adding hints should be avoided,
including:

* Adding hints to variables that has an obvious type.
* Adding hints to variables embedded in functions or classes
  that might be dropped during the next refacto.

What to hint?
~~~~~~~~~~~~~

I decided to add type hints to:
* All methods.
* And all ambiguous parts of the code that makes the static checker complain.

The hints should be readable and concise *unlike C++ types :-)*

.. code-block:: c++
  :linenos:

  static inline std::map<std::string, int> zip_and_map(
      std::list<std::string> keys,
      std::list<int> values) {
    // map keys zipped with values
  }

Talking about static checker...

Setting up the static checker
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The checker I used is the de facto standard Python checker
`Mypy <http://mypy.readthedocs.io/>`_.
Mypy is maintained by Python core developers including
`Guido van Rossum <https://en.wikipedia.org/wiki/Guido_van_Rossum>`_,
the Python language creator.

You can install Mypy with the following command

.. code-block:: shell
  :linenos:

  pip install mypy

The workflow
^^^^^^^^^^^^

Run statical type checking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Normal Run, without any change

.. code-block:: shell
  :linenos:

  mypy --strict --ignore-missing-imports guesslang/

Explanation:

* ``mypy``: mypy command line tool
* ``--strict``: option to check everything,
  will print an **error** or a **warning** if any type issue is found.
* ``--ignore-missing-imports``:
  ignore third party dependencies that lacks type hints.

Add type hints layer by layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

wip...

Fix typing issues
~~~~~~~~~~~~~~~~~

wip...

Any actual benefits?
--------------------

Benefits:
* Better code understanding.
* Better type consistency (list -> tuple).
* New checking in my checking stack:

  - code testing
  - test coverage
  - static type checking
  - code style checking

But:

* Required workarounds to pass the ckecks:

  * ``Any``
  * ``cast``,
  * local variable typing, because of inference.

* No new bug found
